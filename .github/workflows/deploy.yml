name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*'
  workflow_dispatch:  # å…è¨±æ‰‹å‹•è§¸ç™¼

env:
  AWS_REGION: us-east-1  # æ ¹æ“šæ‚¨çš„ EC2 å€åŸŸä¿®æ”¹

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libjpeg-dev zlib1g-dev libheif-dev libde265-dev libfreetype6-dev
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run migrations
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        DEBUG: 'False'
      run: |
        export SECRET_KEY=${SECRET_KEY:-django-insecure-climbing-score-system-dev-key-change-in-production}
        python manage.py migrate --noinput
    
    - name: Run tests
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        DEBUG: 'True'
      run: |
        export SECRET_KEY=${SECRET_KEY:-django-insecure-climbing-score-system-dev-key-change-in-production}
        python manage.py test scoring.tests --verbosity=0
    
    - name: Configure SSH
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      run: |
        if [ -z "$EC2_HOST" ] || [ -z "$EC2_USER" ] || [ -z "$EC2_SSH_KEY" ]; then
          echo "âš ï¸  è·³é SSH é…ç½®ï¼šæœªé…ç½® EC2 secrets"
          exit 0
        fi
        mkdir -p ~/.ssh
        echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts || true
    
    - name: Deploy to EC2
      env:
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      run: |
        if [ -z "$EC2_HOST" ] || [ -z "$EC2_USER" ] || [ -z "$EC2_SSH_KEY" ]; then
          echo "âš ï¸  è·³ééƒ¨ç½²ï¼šæœªé…ç½® EC2 secrets"
          echo "è«‹æª¢æŸ¥ GitHub Secrets é…ç½®ï¼š"
          echo "  - EC2_HOST: ${EC2_HOST:-æœªè¨­ç½®}"
          echo "  - EC2_USER: ${EC2_USER:-æœªè¨­ç½®}"
          echo "  - EC2_SSH_KEY: ${EC2_SSH_KEY:+å·²è¨­ç½®}${EC2_SSH_KEY:-æœªè¨­ç½®}"
          exit 0
        fi
        echo "é–‹å§‹éƒ¨ç½²åˆ° EC2..."
        echo "ç›®æ¨™: ${EC2_USER}@${EC2_HOST}"
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
          ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
          set -e
          set -o pipefail
          
          # é€²å…¥é …ç›®ç›®éŒ„
          cd /var/www/Climbing_score_counter || {
            echo "âŒ éŒ¯èª¤: ç„¡æ³•é€²å…¥é …ç›®ç›®éŒ„ /var/www/Climbing_score_counter"
            exit 1
          }
          
          echo "=== é–‹å§‹éƒ¨ç½² ==="
          echo "æ™‚é–“: $(date)"
          echo "ç•¶å‰ç›®éŒ„: $(pwd)"
          echo "ç•¶å‰ç”¨æˆ¶: $(whoami)"
          echo "ç”¨æˆ¶çµ„: $(groups)"
          
          # è¨ºæ–·ç’°å¢ƒä¿¡æ¯
          echo ""
          echo "ğŸ” ç’°å¢ƒè¨ºæ–·:"
          echo "   HOME: $HOME"
          echo "   PATH: $PATH"
          echo "   SHELL: $SHELL"
          
          # æª¢æŸ¥ Git é…ç½®
          if [ -d ".git" ]; then
            echo ""
            echo "ğŸ” Git é…ç½®æª¢æŸ¥:"
            echo "   é ç¨‹å€‰åº« URL:"
            git remote -v || echo "   ç„¡æ³•ç²å–é ç¨‹å€‰åº«ä¿¡æ¯"
            echo "   Git ç”¨æˆ¶å: $(git config user.name 2>/dev/null || echo 'æœªè¨­ç½®')"
            echo "   Git éƒµç®±: $(git config user.email 2>/dev/null || echo 'æœªè¨­ç½®')"
            
            # æª¢æŸ¥æ˜¯å¦éœ€è¦é…ç½® Git èªè­‰
            REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")
            if echo "$REMOTE_URL" | grep -q "^https://"; then
              echo "   âš ï¸  æª¢æ¸¬åˆ° HTTPS URLï¼Œå¯èƒ½éœ€è¦èªè­‰"
              echo "   å»ºè­°ä½¿ç”¨ SSH URL æˆ–é…ç½® Git æ†‘è­‰"
            elif echo "$REMOTE_URL" | grep -q "^git@"; then
              echo "   âœ… ä½¿ç”¨ SSH URL"
            fi
          fi
          
          # è¨˜éŒ„éƒ¨ç½²å‰çš„ä»£ç¢¼ç‰ˆæœ¬
          OLD_COMMIT=""
          if [ -d ".git" ]; then
            OLD_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            echo ""
            echo "ğŸ“Œ éƒ¨ç½²å‰ä»£ç¢¼ç‰ˆæœ¬: $OLD_COMMIT"
            
            # æª¢æŸ¥ Git æ¬Šé™
            echo "ğŸ” æª¢æŸ¥ Git æ¬Šé™..."
            CURRENT_USER=$(whoami)
            if [ ! -w ".git" ] 2>/dev/null; then
              echo "   âš ï¸  .git ç›®éŒ„ç„¡å¯«æ¬Šé™ï¼Œå˜—è©¦ä¿®å¾©..."
              sudo chown -R $CURRENT_USER:$CURRENT_USER .git 2>/dev/null || {
                echo "   âŒ ç„¡æ³•ä¿®å¾© .git ç›®éŒ„æ¬Šé™"
              }
            fi
            
            # é…ç½® Git å®‰å…¨ç›®éŒ„ï¼ˆå¦‚æœå°šæœªé…ç½®ï¼‰
            if ! git config --global --get safe.directory | grep -q "/var/www/Climbing_score_counter"; then
              echo "   ğŸ”§ é…ç½® Git å®‰å…¨ç›®éŒ„..."
              git config --global --add safe.directory /var/www/Climbing_score_counter || true
            fi
          fi
          
          # æ¸¬è©¦ Git é€£æ¥ï¼ˆåœ¨åŸ·è¡Œéƒ¨ç½²è…³æœ¬å‰ï¼‰
          if [ -d ".git" ]; then
            echo ""
            echo "ğŸ” æ¸¬è©¦ Git é€£æ¥..."
            REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")
            
            # å¦‚æœæ˜¯ HTTPS URLï¼Œå¯èƒ½éœ€è¦é…ç½®èªè­‰
            if echo "$REMOTE_URL" | grep -q "^https://"; then
              echo "   â„¹ï¸  ä½¿ç”¨ HTTPS URLï¼Œæ¸¬è©¦é€£æ¥..."
              # å˜—è©¦ fetchï¼ˆå¯èƒ½æœƒå¤±æ•—ï¼Œä½†ä¸å½±éŸ¿å¾ŒçºŒï¼‰
              if git fetch origin --dry-run 2>&1 | head -5; then
                echo "   âœ… Git fetch æ¸¬è©¦æˆåŠŸ"
              else
                echo "   âš ï¸  Git fetch æ¸¬è©¦å¤±æ•—ï¼ˆå¯èƒ½éœ€è¦èªè­‰ï¼‰"
                echo "   é€™å¯èƒ½å°è‡´éƒ¨ç½²è…³æœ¬ä¸­çš„ git fetch å¤±æ•—"
                echo "   å»ºè­°ï¼š"
                echo "   1. å°‡é ç¨‹ URL æ”¹ç‚º SSH æ ¼å¼ (git@...)"
                echo "   2. æˆ–åœ¨æœå‹™å™¨ä¸Šé…ç½® Git æ†‘è­‰åŠ©æ‰‹"
              fi
            elif echo "$REMOTE_URL" | grep -q "^git@"; then
              echo "   â„¹ï¸  ä½¿ç”¨ SSH URLï¼Œæ¸¬è©¦é€£æ¥..."
              # æ¸¬è©¦ SSH é€£æ¥
              GIT_HOST=$(echo "$REMOTE_URL" | sed -E 's|git@([^:]+):.*|\1|')
              if ssh -o ConnectTimeout=5 -o BatchMode=yes "$GIT_HOST" exit 2>/dev/null; then
                echo "   âœ… SSH é€£æ¥æ¸¬è©¦æˆåŠŸ"
              else
                echo "   âš ï¸  SSH é€£æ¥æ¸¬è©¦å¤±æ•—"
                echo "   å¯èƒ½éœ€è¦é…ç½® SSH key æˆ– known_hosts"
              fi
            fi
          fi
          
          # åŸ·è¡Œéƒ¨ç½²è…³æœ¬ï¼ˆéƒ¨ç½²è…³æœ¬æœƒè™•ç† Git æ›´æ–°ï¼‰
          echo ""
          echo "ğŸš€ åŸ·è¡Œéƒ¨ç½²è…³æœ¬..."
          DEPLOY_SCRIPT="Deployment/scripts/tools/deploy.sh"
          
          if [ ! -f "$DEPLOY_SCRIPT" ]; then
            echo "âŒ éŒ¯èª¤: æ‰¾ä¸åˆ°éƒ¨ç½²è…³æœ¬ $DEPLOY_SCRIPT"
            echo "ç•¶å‰ç›®éŒ„: $(pwd)"
            echo "ç›®éŒ„å…§å®¹:"
            ls -la | head -20
            echo ""
            echo "Deployment ç›®éŒ„å…§å®¹:"
            ls -la Deployment/ 2>/dev/null || echo "Deployment ç›®éŒ„ä¸å­˜åœ¨"
            echo ""
            echo "Deployment/scripts ç›®éŒ„å…§å®¹:"
            ls -la Deployment/scripts/ 2>/dev/null || echo "Deployment/scripts ç›®éŒ„ä¸å­˜åœ¨"
            echo ""
            echo "Deployment/scripts/tools ç›®éŒ„å…§å®¹:"
            ls -la Deployment/scripts/tools/ 2>/dev/null || echo "Deployment/scripts/tools ç›®éŒ„ä¸å­˜åœ¨"
            exit 1
          fi
          
          # ç¢ºä¿è…³æœ¬æœ‰åŸ·è¡Œæ¬Šé™
          chmod +x "$DEPLOY_SCRIPT"
          
          # åŸ·è¡Œéƒ¨ç½²è…³æœ¬ä¸¦æ•ç²éŒ¯èª¤
          echo "åŸ·è¡Œ: bash $DEPLOY_SCRIPT"
          if bash "$DEPLOY_SCRIPT"; then
            echo "âœ… éƒ¨ç½²è…³æœ¬åŸ·è¡ŒæˆåŠŸ"
          else
            EXIT_CODE=$?
            echo "âŒ éƒ¨ç½²è…³æœ¬åŸ·è¡Œå¤±æ•—ï¼Œé€€å‡ºç¢¼: $EXIT_CODE"
            echo "æŸ¥çœ‹éƒ¨ç½²è…³æœ¬éŒ¯èª¤æ—¥èªŒ..."
            exit $EXIT_CODE
          fi
          
          # é©—è­‰ä»£ç¢¼æ˜¯å¦æ›´æ–°
          echo ""
          echo "ğŸ” é©—è­‰ä»£ç¢¼æ›´æ–°..."
          if [ -d ".git" ]; then
            NEW_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            echo "ğŸ“Œ éƒ¨ç½²å¾Œä»£ç¢¼ç‰ˆæœ¬: $NEW_COMMIT"
            
            # ç²å–é ç¨‹æœ€æ–°ç‰ˆæœ¬ï¼ˆå¤šæ¬¡å˜—è©¦ï¼‰
            echo "ğŸ“¥ ç²å–é ç¨‹æœ€æ–°ç‰ˆæœ¬..."
            FETCH_SUCCESS=false
            for i in 1 2 3; do
              echo "   å˜—è©¦ $i/3..."
              if git fetch origin 2>&1; then
                FETCH_SUCCESS=true
                echo "   âœ… Git fetch æˆåŠŸ"
                break
              else
                FETCH_ERROR=$?
                echo "   âš ï¸  å˜—è©¦ $i å¤±æ•—ï¼Œé€€å‡ºç¢¼: $FETCH_ERROR"
                if [ $i -lt 3 ]; then
                  echo "   ç­‰å¾… 2 ç§’å¾Œé‡è©¦..."
                  sleep 2
                fi
              fi
            done
            
            if [ "$FETCH_SUCCESS" = "false" ]; then
              echo "   âŒ æ‰€æœ‰ Git fetch å˜—è©¦éƒ½å¤±æ•—"
              echo "   è¨ºæ–·ä¿¡æ¯:"
              echo "   é ç¨‹ URL: $(git remote get-url origin 2>/dev/null || echo 'ç„¡æ³•ç²å–')"
              echo "   ç•¶å‰åˆ†æ”¯: $(git branch --show-current 2>/dev/null || echo 'unknown')"
              echo "   Git ç‹€æ…‹:"
              git status --short 2>/dev/null | head -5 || echo "   ç„¡æ³•ç²å–ç‹€æ…‹"
              echo ""
              echo "   âš ï¸  ç¹¼çºŒåŸ·è¡Œï¼Œä½†ä»£ç¢¼å¯èƒ½ä¸æ˜¯æœ€æ–°ç‰ˆæœ¬"
            fi
            
            REMOTE_MAIN_COMMIT=$(git rev-parse --short origin/main 2>/dev/null || echo "unknown")
            REMOTE_MASTER_COMMIT=$(git rev-parse --short origin/master 2>/dev/null || echo "unknown")
            REMOTE_COMMIT="$REMOTE_MAIN_COMMIT"
            if [ "$REMOTE_COMMIT" = "unknown" ]; then
              REMOTE_COMMIT="$REMOTE_MASTER_COMMIT"
            fi
            
            echo "ğŸ“Œ é ç¨‹æœ€æ–°ç‰ˆæœ¬: $REMOTE_COMMIT"
            echo "ğŸ“Œ æœ¬åœ°ç•¶å‰ç‰ˆæœ¬: $NEW_COMMIT"
            echo "ğŸ“Œ éƒ¨ç½²å‰ç‰ˆæœ¬: $OLD_COMMIT"
            
            # æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
            if [ "$REMOTE_COMMIT" != "unknown" ] && [ "$NEW_COMMIT" != "unknown" ] && [ "$REMOTE_COMMIT" != "$NEW_COMMIT" ]; then
              echo "âš ï¸  è­¦å‘Š: æœ¬åœ°ç‰ˆæœ¬èˆ‡é ç¨‹ç‰ˆæœ¬ä¸ä¸€è‡´"
              echo "   é ç¨‹: $REMOTE_COMMIT"
              echo "   æœ¬åœ°: $NEW_COMMIT"
              echo "   å¼·åˆ¶æ›´æ–°åˆ°é ç¨‹ç‰ˆæœ¬..."
              
              # å‚™ä»½æ•¸æ“šåº«
              if [ -f "db.sqlite3" ]; then
                mkdir -p backups
                cp db.sqlite3 "backups/db_backup_before_force_update_$(date +%Y%m%d_%H%M%S).sqlite3" 2>/dev/null || true
              fi
              
              # å¼·åˆ¶é‡ç½®
              if [ "$REMOTE_MAIN_COMMIT" != "unknown" ]; then
                git reset --hard origin/main || {
                  echo "âŒ éŒ¯èª¤: ç„¡æ³•é‡ç½®åˆ° origin/main"
                  exit 1
                }
              elif [ "$REMOTE_MASTER_COMMIT" != "unknown" ]; then
                git reset --hard origin/master || {
                  echo "âŒ éŒ¯èª¤: ç„¡æ³•é‡ç½®åˆ° origin/master"
                  exit 1
                }
              fi
              
              NEW_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
              echo "âœ… å·²å¼·åˆ¶æ›´æ–°åˆ°: $NEW_COMMIT"
              
              # å¦‚æœä»£ç¢¼æ›´æ–°äº†ï¼Œéœ€è¦é‡æ–°åŸ·è¡Œéƒ¨ç½²æ­¥é©Ÿ
              if [ "$NEW_COMMIT" != "$OLD_COMMIT" ]; then
                echo "ğŸ”„ ä»£ç¢¼å·²æ›´æ–°ï¼Œé‡æ–°åŸ·è¡Œéƒ¨ç½²æ­¥é©Ÿ..."
                source venv/bin/activate 2>/dev/null || true
                python manage.py migrate --noinput || true
                python manage.py collectstatic --noinput --clear || true
                sudo systemctl daemon-reload
                sudo systemctl restart climbing_system || {
                  echo "âŒ æœå‹™é‡å•Ÿå¤±æ•—"
                  sudo journalctl -u climbing_system --no-pager -n 30
                  exit 1
                }
              fi
            elif [ "$OLD_COMMIT" != "unknown" ] && [ "$NEW_COMMIT" != "unknown" ] && [ "$OLD_COMMIT" = "$NEW_COMMIT" ]; then
              echo "â„¹ï¸  ä»£ç¢¼ç‰ˆæœ¬æœªè®Šæ›´ï¼ˆå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼‰"
              if [ "$REMOTE_COMMIT" != "unknown" ] && [ "$REMOTE_COMMIT" = "$NEW_COMMIT" ]; then
                echo "âœ… ç¢ºèª: æœ¬åœ°ç‰ˆæœ¬èˆ‡é ç¨‹ç‰ˆæœ¬ä¸€è‡´"
              fi
            else
              if [ "$OLD_COMMIT" != "unknown" ] && [ "$NEW_COMMIT" != "unknown" ]; then
                echo "âœ… ä»£ç¢¼å·²æ›´æ–°: $OLD_COMMIT -> $NEW_COMMIT"
              fi
            fi
            
            # é¡¯ç¤ºæœ€æ–°æäº¤ä¿¡æ¯
            echo ""
            echo "ğŸ“‹ æœ€æ–°æäº¤ä¿¡æ¯:"
            git log -1 --oneline --decorate 2>/dev/null || echo "ç„¡æ³•ç²å–æäº¤ä¿¡æ¯"
            
            # æª¢æŸ¥å·¥ä½œå€ç‹€æ…‹
            echo ""
            echo "ğŸ“‹ å·¥ä½œå€ç‹€æ…‹:"
            if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
              echo "âš ï¸  è­¦å‘Š: æª¢æ¸¬åˆ°æœªæäº¤çš„ä¿®æ”¹"
              git status --short | head -10
            else
              echo "âœ… å·¥ä½œå€ä¹¾æ·¨"
            fi
          else
            echo "âš ï¸  è­¦å‘Š: æœªæª¢æ¸¬åˆ° Git å€‰åº«"
          fi
          
          # ç­‰å¾…æœå‹™å•Ÿå‹•
          echo ""
          echo "â³ ç­‰å¾…æœå‹™å•Ÿå‹•ï¼ˆ5ç§’ï¼‰..."
          sleep 5
          
          # é©—è­‰æœå‹™ç‹€æ…‹
          echo ""
          echo "ğŸ“Š æœå‹™ç‹€æ…‹æª¢æŸ¥:"
          if sudo systemctl is-active --quiet climbing_system; then
            echo "âœ… climbing_system æœå‹™æ­£åœ¨é‹è¡Œ"
          else
            echo "âŒ climbing_system æœå‹™æœªé‹è¡Œ"
            echo "å˜—è©¦å•Ÿå‹•æœå‹™..."
            sudo systemctl start climbing_system || true
            sleep 3
            if sudo systemctl is-active --quiet climbing_system; then
              echo "âœ… æœå‹™å·²å•Ÿå‹•"
            else
              echo "âŒ æœå‹™å•Ÿå‹•å¤±æ•—"
              echo "æœå‹™ç‹€æ…‹:"
              sudo systemctl status climbing_system --no-pager -l || true
              echo ""
              echo "æœå‹™æ—¥èªŒï¼ˆæœ€è¿‘30è¡Œï¼‰:"
              sudo journalctl -u climbing_system --no-pager -n 30 || true
              exit 1
            fi
          fi
          
          # æª¢æŸ¥æœå‹™è©³ç´°ç‹€æ…‹
          echo ""
          echo "ğŸ“‹ æœå‹™è©³ç´°ç‹€æ…‹:"
          sudo systemctl status climbing_system --no-pager -l | head -20 || true
          
          # é©—è­‰ç«¯å£ç›£è½
          echo ""
          echo "ğŸ”Œ æª¢æŸ¥ç«¯å£ç›£è½ç‹€æ…‹:"
          if sudo netstat -tlnp 2>/dev/null | grep -q ':8000 ' || sudo ss -tlnp 2>/dev/null | grep -q ':8000 '; then
            echo "âœ… ç«¯å£ 8000 æ­£åœ¨ç›£è½"
            sudo netstat -tlnp 2>/dev/null | grep ':8000 ' || sudo ss -tlnp 2>/dev/null | grep ':8000 '
          else
            echo "âš ï¸  è­¦å‘Š: ç«¯å£ 8000 æœªç›£è½"
            echo "å˜—è©¦é‡å•Ÿæœå‹™..."
            sudo systemctl restart climbing_system
            sleep 3
            if sudo netstat -tlnp 2>/dev/null | grep -q ':8000 ' || sudo ss -tlnp 2>/dev/null | grep -q ':8000 '; then
              echo "âœ… ç«¯å£ç¾åœ¨æ­£åœ¨ç›£è½"
            else
              echo "âŒ ç«¯å£ä»æœªç›£è½"
            fi
          fi
          
          # æ¸¬è©¦æœ¬åœ°é€£æ¥
          echo ""
          echo "ğŸŒ æ¸¬è©¦æœ¬åœ°é€£æ¥:"
          LOCAL_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 http://127.0.0.1:8000/ 2>/dev/null || echo "000")
          if [ "$LOCAL_RESPONSE" = "200" ] || [ "$LOCAL_RESPONSE" = "301" ] || [ "$LOCAL_RESPONSE" = "302" ] || [ "$LOCAL_RESPONSE" = "400" ]; then
            echo "âœ… æœ¬åœ°é€£æ¥æ­£å¸¸ (HTTP $LOCAL_RESPONSE)"
          else
            echo "âš ï¸  è­¦å‘Š: æœ¬åœ°é€£æ¥ç•°å¸¸ (HTTP $LOCAL_RESPONSE)"
          fi
          
          echo ""
          echo "=== éƒ¨ç½²å®Œæˆ ==="
          echo "æ™‚é–“: $(date)"
          echo "âœ… æ‰€æœ‰æª¢æŸ¥å®Œæˆ"
        ENDSSH
    
    - name: Skip deployment notice
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      if: env.EC2_HOST == '' || env.EC2_USER == '' || env.EC2_SSH_KEY == ''
      run: |
        echo "âš ï¸  è·³ééƒ¨ç½²ï¼šæœªé…ç½® EC2 secrets"
        echo "è«‹åœ¨ GitHub å€‰åº«è¨­ç½®ä¸­é…ç½®ä»¥ä¸‹ secretsï¼š"
        echo "  - EC2_HOST: EC2 å¯¦ä¾‹ IP æˆ–åŸŸå"
        echo "  - EC2_USER: SSH ç”¨æˆ¶åï¼ˆé€šå¸¸æ˜¯ ubuntuï¼‰"
        echo "  - EC2_SSH_KEY: SSH ç§é‘°å…§å®¹"
        echo ""
        echo "æ¸¬è©¦å·²é€šéï¼Œä½†éƒ¨ç½²æ­¥é©Ÿå·²è·³éã€‚"
    
    - name: Verify deployment
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
      if: env.EC2_HOST != ''
      continue-on-error: true
      run: |
        sleep 5
        response=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 http://$EC2_HOST || echo "000")
        if [ "$response" = "000" ]; then
          echo "âš ï¸  è­¦å‘Š: ç„¡æ³•é€£æ¥åˆ°æœå‹™å™¨ï¼ˆå¯èƒ½æœªé…ç½® EC2_HOST secret æˆ–æœå‹™å™¨æœªé‹è¡Œï¼‰"
          echo "é€™ä¸æœƒå°è‡´éƒ¨ç½²å¤±æ•—ï¼Œä½†è«‹æª¢æŸ¥æœå‹™å™¨ç‹€æ…‹"
        elif [ "$response" != "200" ]; then
          echo "âš ï¸  è­¦å‘Š: éƒ¨ç½²å¾Œæœå‹™éŸ¿æ‡‰ç‹€æ…‹ç¢¼ç‚º $responseï¼ˆé æœŸ 200ï¼‰"
          echo "é€™ä¸æœƒå°è‡´éƒ¨ç½²å¤±æ•—ï¼Œä½†è«‹æª¢æŸ¥æœå‹™å™¨æ—¥èªŒ"
        else
          echo "âœ… éƒ¨ç½²é©—è­‰æˆåŠŸï¼Œæœå‹™éŸ¿æ‡‰æ­£å¸¸ï¼ˆHTTP $responseï¼‰"
        fi

